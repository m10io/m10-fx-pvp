// @generated by protobuf-ts 2.7.0
// @generated from protobuf file "metadata.proto" (package "m10.pvp.metadata", syntax proto3)
// tslint:disable
import type {BinaryWriteOptions} from '@protobuf-ts/runtime'
import type {IBinaryWriter} from '@protobuf-ts/runtime'
import {WireType} from '@protobuf-ts/runtime'
import type {BinaryReadOptions} from '@protobuf-ts/runtime'
import type {IBinaryReader} from '@protobuf-ts/runtime'
import {UnknownFieldHandler} from '@protobuf-ts/runtime'
import type {PartialMessage} from '@protobuf-ts/runtime'
import {reflectionMergePartial} from '@protobuf-ts/runtime'
import {MESSAGE_TYPE} from '@protobuf-ts/runtime'
import {MessageType} from '@protobuf-ts/runtime'
/**
 * @generated from protobuf message m10.pvp.metadata.FxAgreement
 */
export interface FxAgreement {
    /**
     * / Serialized [`FxQuote`]
     *
     * @generated from protobuf field: bytes quote = 1;
     */
    quote: Uint8Array;
    /**
     * @generated from protobuf field: repeated m10.pvp.metadata.Signature signatures = 2;
     */
    signatures: Signature[];
}
/**
 * @generated from protobuf message m10.pvp.metadata.FxQuote
 */
export interface FxQuote {
    /**
     * @generated from protobuf field: m10.pvp.metadata.FxAmount base = 1;
     */
    base?: FxAmount;
    /**
     * @generated from protobuf field: m10.pvp.metadata.FxAmount target = 2;
     */
    target?: FxAmount;
    /**
     * @generated from protobuf field: uint64 nonce = 3;
     */
    nonce: bigint;
}
/**
 * @generated from protobuf message m10.pvp.metadata.FxAmount
 */
export interface FxAmount {
    /**
     * Value
     *
     * @generated from protobuf field: uint64 amount = 1;
     */
    amount: bigint;
    /**
     * Currency shorthand, e.g. 'USD'
     *
     * @generated from protobuf field: string currency = 2;
     */
    currency: string;
    /**
     * M10 Ledger identifier
     *
     * @generated from protobuf field: string ledger = 3;
     */
    ledger: string;
}
/**
 * @generated from protobuf message m10.pvp.metadata.Signature
 */
export interface Signature {
    /**
     * @generated from protobuf field: bytes public_key = 2;
     */
    publicKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes signature = 3;
     */
    signature: Uint8Array;
    /**
     * @generated from protobuf field: m10.pvp.metadata.Algorithm algorithm = 4;
     */
    algorithm: Algorithm;
}
/**
 * @generated from protobuf enum m10.pvp.metadata.Algorithm
 */
export enum Algorithm {
    /**
     * @generated from protobuf enum value: P256_SHA256_ASN1 = 0;
     */
    P256_SHA256_ASN1 = 0,
    /**
     * @generated from protobuf enum value: ED25519 = 1;
     */
    ED25519 = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class FxAgreement$Type extends MessageType<FxAgreement> {
  constructor() {
    super('m10.pvp.metadata.FxAgreement', [
      {no: 1, name: 'quote', kind: 'scalar', T: 12 /* ScalarType.BYTES */},
      {no: 2, name: 'signatures', kind: 'message', repeat: 1 /* RepeatType.PACKED */, T: () => Signature},
    ])
  }

  create(value?: PartialMessage<FxAgreement>): FxAgreement {
    const message = {quote: new Uint8Array(0), signatures: []}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {enumerable: false, value: this})
    if (value !== undefined)
      reflectionMergePartial<FxAgreement>(this, message, value)
    return message
  }

  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FxAgreement): FxAgreement {
    const message = target ?? this.create(); const
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
      case /* bytes quote */ 1:
        message.quote = reader.bytes()
        break
      case /* repeated m10.pvp.metadata.Signature signatures */ 2:
        message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options))
        break
      default:
        const u = options.readUnknownField
        if (u === 'throw')
          throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
        const d = reader.skip(wireType)
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }

    return message
  }

  internalBinaryWrite(message: FxAgreement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* bytes quote = 1; */
    if (message.quote.length > 0)
      writer.tag(1, WireType.LengthDelimited).bytes(message.quote)
    /* repeated m10.pvp.metadata.Signature signatures = 2; */
    for (let i = 0; i < message.signatures.length; i++)
      Signature.internalBinaryWrite(message.signatures[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join(',')
    const u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message m10.pvp.metadata.FxAgreement
 */
export const FxAgreement = new FxAgreement$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FxQuote$Type extends MessageType<FxQuote> {
  constructor() {
    super('m10.pvp.metadata.FxQuote', [
      {no: 1, name: 'base', kind: 'message', T: () => FxAmount},
      {no: 2, name: 'target', kind: 'message', T: () => FxAmount},
      {no: 3, name: 'nonce', kind: 'scalar', T: 4 /* ScalarType.UINT64 */, L: 0 /* LongType.BIGINT */},
    ])
  }

  create(value?: PartialMessage<FxQuote>): FxQuote {
    const message = {nonce: 0n}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {enumerable: false, value: this})
    if (value !== undefined)
      reflectionMergePartial<FxQuote>(this, message, value)
    return message
  }

  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FxQuote): FxQuote {
    const message = target ?? this.create(); const
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
      case /* m10.pvp.metadata.FxAmount base */ 1:
        message.base = FxAmount.internalBinaryRead(reader, reader.uint32(), options, message.base)
        break
      case /* m10.pvp.metadata.FxAmount target */ 2:
        message.target = FxAmount.internalBinaryRead(reader, reader.uint32(), options, message.target)
        break
      case /* uint64 nonce */ 3:
        message.nonce = reader.uint64().toBigInt()
        break
      default:
        const u = options.readUnknownField
        if (u === 'throw')
          throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
        const d = reader.skip(wireType)
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }

    return message
  }

  internalBinaryWrite(message: FxQuote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* m10.pvp.metadata.FxAmount base = 1; */
    if (message.base)
      FxAmount.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join(',')
    /* m10.pvp.metadata.FxAmount target = 2; */
    if (message.target)
      FxAmount.internalBinaryWrite(message.target, writer.tag(2, WireType.LengthDelimited).fork(), options).join(',')
    /* uint64 nonce = 3; */
    if (message.nonce !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.nonce)
    const u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message m10.pvp.metadata.FxQuote
 */
export const FxQuote = new FxQuote$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FxAmount$Type extends MessageType<FxAmount> {
  constructor() {
    super('m10.pvp.metadata.FxAmount', [
      {no: 1, name: 'amount', kind: 'scalar', T: 4 /* ScalarType.UINT64 */, L: 0 /* LongType.BIGINT */},
      {no: 2, name: 'currency', kind: 'scalar', T: 9 /* ScalarType.STRING */},
      {no: 3, name: 'ledger', kind: 'scalar', T: 9 /* ScalarType.STRING */},
    ])
  }

  create(value?: PartialMessage<FxAmount>): FxAmount {
    const message = {amount: 0n, currency: '', ledger: ''}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {enumerable: false, value: this})
    if (value !== undefined)
      reflectionMergePartial<FxAmount>(this, message, value)
    return message
  }

  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FxAmount): FxAmount {
    const message = target ?? this.create(); const
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
      case /* uint64 amount */ 1:
        message.amount = reader.uint64().toBigInt()
        break
      case /* string currency */ 2:
        message.currency = reader.string()
        break
      case /* string ledger */ 3:
        message.ledger = reader.string()
        break
      default:
        const u = options.readUnknownField
        if (u === 'throw')
          throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
        const d = reader.skip(wireType)
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }

    return message
  }

  internalBinaryWrite(message: FxAmount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* uint64 amount = 1; */
    if (message.amount !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.amount)
    /* string currency = 2; */
    if (message.currency !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.currency)
    /* string ledger = 3; */
    if (message.ledger !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.ledger)
    const u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message m10.pvp.metadata.FxAmount
 */
export const FxAmount = new FxAmount$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
  constructor() {
    super('m10.pvp.metadata.Signature', [
      {no: 2, name: 'public_key', kind: 'scalar', T: 12 /* ScalarType.BYTES */},
      {no: 3, name: 'signature', kind: 'scalar', T: 12 /* ScalarType.BYTES */},
      {no: 4, name: 'algorithm', kind: 'enum', T: () => ['m10.pvp.metadata.Algorithm', Algorithm]},
    ])
  }

  create(value?: PartialMessage<Signature>): Signature {
    const message = {publicKey: new Uint8Array(0), signature: new Uint8Array(0), algorithm: 0}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {enumerable: false, value: this})
    if (value !== undefined)
      reflectionMergePartial<Signature>(this, message, value)
    return message
  }

  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {
    const message = target ?? this.create(); const
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
      case /* bytes public_key */ 2:
        message.publicKey = reader.bytes()
        break
      case /* bytes signature */ 3:
        message.signature = reader.bytes()
        break
      case /* m10.pvp.metadata.Algorithm algorithm */ 4:
        message.algorithm = reader.int32()
        break
      default:
        const u = options.readUnknownField
        if (u === 'throw')
          throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`)
        const d = reader.skip(wireType)
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }

    return message
  }

  internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* bytes public_key = 2; */
    if (message.publicKey.length > 0)
      writer.tag(2, WireType.LengthDelimited).bytes(message.publicKey)
    /* bytes signature = 3; */
    if (message.signature.length > 0)
      writer.tag(3, WireType.LengthDelimited).bytes(message.signature)
    /* m10.pvp.metadata.Algorithm algorithm = 4; */
    if (message.algorithm !== 0)
      writer.tag(4, WireType.Varint).int32(message.algorithm)
    const u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message m10.pvp.metadata.Signature
 */
export const Signature = new Signature$Type()
